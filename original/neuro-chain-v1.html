<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neuro-Chain: Evolution of Human Invention</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=JetBrains+Mono:wght@300;400&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --bg-deep: #0a0a0f;
            --bg-surface: #12121a;
            --fire-core: #ff6b35;
            --fire-glow: #ff9f1c;
            --energy-pulse: #e63946;
            --bio-green: #2a9d8f;
            --info-blue: #4cc9f0;
            --tool-amber: #f4a261;
            --agi-violet: #9d4edd;
            --text-primary: #e8e6e3;
            --text-muted: #6b7280;
            --grid-line: rgba(255,255,255,0.03);
        }
        
        html, body {
            height: 100%;
            overflow: hidden;
        }
        
        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-deep);
            color: var(--text-primary);
            position: relative;
        }
        
        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background: 
                radial-gradient(ellipse 80% 50% at 50% 0%, rgba(255,107,53,0.08) 0%, transparent 50%),
                radial-gradient(ellipse 60% 40% at 80% 100%, rgba(157,78,221,0.06) 0%, transparent 40%),
                repeating-linear-gradient(0deg, transparent, transparent 100px, var(--grid-line) 100px, var(--grid-line) 101px),
                repeating-linear-gradient(90deg, transparent, transparent 100px, var(--grid-line) 100px, var(--grid-line) 101px);
            pointer-events: none;
            z-index: 0;
        }
        
        #canvas-container {
            position: fixed;
            inset: 0;
            z-index: 1;
        }
        
        canvas {
            display: block;
        }
        
        .ui-layer {
            position: fixed;
            z-index: 10;
            pointer-events: none;
        }
        
        .title-block {
            top: 2rem;
            left: 2rem;
            pointer-events: auto;
        }
        
        .title-block h1 {
            font-family: 'Playfair Display', serif;
            font-size: 2.5rem;
            font-weight: 700;
            letter-spacing: -0.02em;
            background: linear-gradient(135deg, var(--fire-glow), var(--fire-core));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.5rem;
        }
        
        .title-block .subtitle {
            font-size: 0.75rem;
            color: var(--text-muted);
            letter-spacing: 0.2em;
            text-transform: uppercase;
        }
        
        .legend {
            bottom: 2rem;
            left: 2rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            pointer-events: auto;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 0.7rem;
            color: var(--text-muted);
            transition: color 0.2s;
            cursor: pointer;
        }
        
        .legend-item:hover {
            color: var(--text-primary);
        }
        
        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            box-shadow: 0 0 10px currentColor;
        }
        
        .cluster-panel {
            top: 2rem;
            right: 2rem;
            bottom: 2rem;
            width: 380px;
            background: rgba(18,18,26,0.95);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 4px;
            padding: 1.5rem;
            overflow-y: auto;
            pointer-events: auto;
            backdrop-filter: blur(20px);
        }
        
        .cluster-panel::-webkit-scrollbar {
            width: 4px;
        }
        
        .cluster-panel::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .cluster-panel::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
        }
        
        .panel-header {
            font-family: 'Playfair Display', serif;
            font-size: 1.1rem;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid rgba(255,255,255,0.08);
        }
        
        .cluster-section {
            margin-bottom: 1.5rem;
            opacity: 0;
            transform: translateY(10px);
            animation: fadeInUp 0.4s ease forwards;
        }
        
        .cluster-section:nth-child(1) { animation-delay: 0.1s; }
        .cluster-section:nth-child(2) { animation-delay: 0.2s; }
        .cluster-section:nth-child(3) { animation-delay: 0.3s; }
        .cluster-section:nth-child(4) { animation-delay: 0.4s; }
        .cluster-section:nth-child(5) { animation-delay: 0.5s; }
        .cluster-section:nth-child(6) { animation-delay: 0.6s; }
        
        @keyframes fadeInUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .cluster-title {
            font-size: 0.8rem;
            font-weight: 400;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .cluster-title::before {
            content: '';
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }
        
        .cluster-title.fire::before { background: var(--fire-core); box-shadow: 0 0 12px var(--fire-core); }
        .cluster-title.energy::before { background: var(--energy-pulse); box-shadow: 0 0 12px var(--energy-pulse); }
        .cluster-title.tools::before { background: var(--tool-amber); box-shadow: 0 0 12px var(--tool-amber); }
        .cluster-title.bio::before { background: var(--bio-green); box-shadow: 0 0 12px var(--bio-green); }
        .cluster-title.info::before { background: var(--info-blue); box-shadow: 0 0 12px var(--info-blue); }
        .cluster-title.agi::before { background: var(--agi-violet); box-shadow: 0 0 12px var(--agi-violet); }
        
        .cluster-body {
            font-size: 0.75rem;
            line-height: 1.7;
            color: var(--text-muted);
        }
        
        .cluster-body strong {
            color: var(--text-primary);
            font-weight: 400;
        }
        
        .link-annotation {
            display: inline-block;
            font-size: 0.65rem;
            padding: 0.15rem 0.4rem;
            background: rgba(255,255,255,0.05);
            border-radius: 2px;
            margin: 0.25rem 0.25rem 0.25rem 0;
            color: var(--text-primary);
        }
        
        .backlink {
            background: rgba(255,107,53,0.15);
            border: 1px solid rgba(255,107,53,0.3);
        }
        
        .controls {
            bottom: 2rem;
            right: 420px;
            display: flex;
            gap: 0.5rem;
            pointer-events: auto;
        }
        
        .control-btn {
            width: 36px;
            height: 36px;
            background: rgba(18,18,26,0.9);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 4px;
            color: var(--text-muted);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .control-btn:hover {
            background: rgba(255,255,255,0.05);
            color: var(--text-primary);
            border-color: rgba(255,255,255,0.2);
        }
        
        .node-tooltip {
            position: fixed;
            background: rgba(18,18,26,0.95);
            border: 1px solid rgba(255,255,255,0.15);
            padding: 0.75rem 1rem;
            border-radius: 4px;
            font-size: 0.75rem;
            pointer-events: none;
            opacity: 0;
            transform: translateY(5px);
            transition: all 0.15s ease;
            max-width: 250px;
            z-index: 100;
            backdrop-filter: blur(10px);
        }
        
        .node-tooltip.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        .tooltip-title {
            font-family: 'Playfair Display', serif;
            font-size: 0.9rem;
            margin-bottom: 0.35rem;
        }
        
        .tooltip-cluster {
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.5rem;
        }
        
        .tooltip-connections {
            font-size: 0.7rem;
            color: var(--text-muted);
        }
        
        .infinite-marker {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.65rem;
            color: var(--text-muted);
            letter-spacing: 0.3em;
            text-transform: uppercase;
            opacity: 0.5;
        }
        
        .pulse-ring {
            position: absolute;
            border-radius: 50%;
            border: 1px solid;
            animation: pulseExpand 3s ease-out infinite;
            pointer-events: none;
        }
        
        @keyframes pulseExpand {
            0% {
                transform: scale(1);
                opacity: 0.6;
            }
            100% {
                transform: scale(3);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="network"></canvas>
    </div>
    
    <div class="ui-layer title-block">
        <h1>Neuro-Chain</h1>
        <div class="subtitle">Evolution of Human Invention</div>
    </div>
    
    <div class="ui-layer legend">
        <div class="legend-item" data-cluster="fire">
            <span class="legend-dot" style="color: var(--fire-core)"></span>
            <span>Fire Cluster</span>
        </div>
        <div class="legend-item" data-cluster="energy">
            <span class="legend-dot" style="color: var(--energy-pulse)"></span>
            <span>Energy Systems</span>
        </div>
        <div class="legend-item" data-cluster="tools">
            <span class="legend-dot" style="color: var(--tool-amber)"></span>
            <span>Tool Chain</span>
        </div>
        <div class="legend-item" data-cluster="bio">
            <span class="legend-dot" style="color: var(--bio-green)"></span>
            <span>Biological</span>
        </div>
        <div class="legend-item" data-cluster="info">
            <span class="legend-dot" style="color: var(--info-blue)"></span>
            <span>Information</span>
        </div>
        <div class="legend-item" data-cluster="agi">
            <span class="legend-dot" style="color: var(--agi-violet)"></span>
            <span>AGI Hub</span>
        </div>
    </div>
    
    <div class="ui-layer cluster-panel">
        <div class="panel-header">Cluster Analysis</div>
        
        <div class="cluster-section">
            <div class="cluster-title fire">Fire Cluster — The Primordial Hub</div>
            <div class="cluster-body">
                <strong>Fire</strong> emerges not as beginning but as the first <em>high-connectivity node</em>—a 
                natural phenomenon captured and sustained. Its constraint profile: <strong>oxygen, fuel, ignition energy</strong>.
                <br><br>
                Fire immediately spawns parallel chains: <strong>cooking</strong> (biology fork—caloric density enables 
                brain expansion), <strong>warmth</strong> (habitat expansion), <strong>light</strong> (temporal liberation—
                activity after dark), and <strong>material transformation</strong> (ceramics, metallurgy).
                <br><br>
                <span class="link-annotation">→ Metallurgy</span>
                <span class="link-annotation">→ Cooking</span>
                <span class="link-annotation">→ Shelter</span>
                <span class="link-annotation backlink">← Friction (tool)</span>
            </div>
        </div>
        
        <div class="cluster-section">
            <div class="cluster-title energy">Energy Systems — Constraint Cascade</div>
            <div class="cluster-body">
                Fire's offspring: <strong>steam</strong> (fire + water containment), <strong>internal combustion</strong> 
                (fire + mechanical precision + refined fuel), <strong>electricity</strong> (magnetism + motion + 
                conductive materials).
                <br><br>
                Each step multiplies constraints: steam requires <strong>metallurgy for pressure vessels</strong>; 
                electricity requires <strong>copper mining, rubber insulation, magnetic theory</strong>. Energy 
                density becomes the master constraint—<strong>nuclear fission</strong> loops back to fundamental 
                physics, <strong>solar</strong> reactivates ancient photosynthesis pathways.
                <br><br>
                <span class="link-annotation backlink">← Fire</span>
                <span class="link-annotation">→ Grid Infrastructure</span>
                <span class="link-annotation">→ Computing</span>
                <span class="link-annotation backlink">← Metallurgy</span>
            </div>
        </div>
        
        <div class="cluster-section">
            <div class="cluster-title tools">Tool Chain — Recursive Self-Improvement</div>
            <div class="cluster-body">
                <strong>Stone tools</strong> predate fire—the first manufactured edges. Tools make tools: 
                <strong>hammers shape chisels, chisels shape dies, dies stamp precision parts</strong>.
                <br><br>
                The <strong>lathe</strong> is a phase transition: round symmetry enables bearings, shafts, 
                threads. Precision measurement (<strong>calipers, micrometers</strong>) creates feedback loops 
                for tolerance reduction. <strong>Machine tools</strong> hit self-replication: machines that 
                build machines.
                <br><br>
                <span class="link-annotation">→ Manufacturing</span>
                <span class="link-annotation">→ Robotics</span>
                <span class="link-annotation backlink">← Metallurgy</span>
                <span class="link-annotation backlink">← Fire (hardening)</span>
            </div>
        </div>
        
        <div class="cluster-section">
            <div class="cluster-title bio">Biological Chain — Wet Substrate</div>
            <div class="cluster-body">
                <strong>Agriculture</strong> emerges from observation + seasonal memory + seed storage. 
                Constraint: <strong>arable land, water, labor</strong>. Spawns <strong>irrigation, selective 
                breeding, fermentation</strong>.
                <br><br>
                <strong>Medicine</strong> branches: herbalism → chemistry → germ theory → antibiotics → 
                gene editing. <strong>CRISPR</strong> loops back to information cluster (DNA as code). 
                <strong>Synthetic biology</strong> merges with manufacturing—living factories.
                <br><br>
                <span class="link-annotation backlink">← Fire (cooking)</span>
                <span class="link-annotation">→ Genetic Engineering</span>
                <span class="link-annotation">→ Neural Interfaces</span>
                <span class="link-annotation backlink">← Microscopy (tools)</span>
            </div>
        </div>
        
        <div class="cluster-section">
            <div class="cluster-title info">Information Chain — Pattern Persistence</div>
            <div class="cluster-body">
                <strong>Language</strong> is the substrate—symbols externalize cognition. <strong>Writing</strong> 
                decouples information from biological memory. <strong>Printing</strong> enables mass replication; 
                <strong>telegraph</strong> breaks distance constraint; <strong>computing</strong> breaks processing 
                constraint.
                <br><br>
                <strong>Transistor</strong> is a mega-hub: spawns all digital technology. Constraint cascade: 
                <strong>silicon purity, photolithography precision, quantum tunneling limits</strong>. 
                <strong>Internet</strong> creates global nervous system; <strong>machine learning</strong> 
                discovers patterns in data oceans.
                <br><br>
                <span class="link-annotation">→ AGI</span>
                <span class="link-annotation backlink">← Electricity</span>
                <span class="link-annotation backlink">← Precision tools</span>
                <span class="link-annotation">→ Quantum Computing</span>
            </div>
        </div>
        
        <div class="cluster-section">
            <div class="cluster-title agi">AGI Hub — Dense Convergence</div>
            <div class="cluster-body">
                Not an endpoint—a <strong>hyperdense node</strong> where all chains converge. Requires: 
                <strong>massive compute (energy), precision fabrication (tools), neural architecture insights 
                (biology), algorithmic theory (information), training data (all human knowledge)</strong>.
                <br><br>
                AGI becomes a <strong>new fire</strong>: a general-purpose enabler spawning unpredictable 
                chains. Back-propagates value to: <strong>chip manufacturing, rare earth mining, power grid 
                capacity, cooling systems</strong>. The constraint envelope: <strong>alignment, energy, 
                interpretability, governance</strong>.
                <br><br>
                <span class="link-annotation backlink">← All Clusters</span>
                <span class="link-annotation">→ ?</span>
                <span class="link-annotation">→ ?</span>
                <span class="link-annotation">→ ∞</span>
            </div>
        </div>
    </div>
    
    <div class="ui-layer controls">
        <button class="control-btn" id="resetView" title="Reset View">⟲</button>
        <button class="control-btn" id="toggleAnimation" title="Pause/Play">⏸</button>
    </div>
    
    <div class="node-tooltip" id="tooltip">
        <div class="tooltip-title"></div>
        <div class="tooltip-cluster"></div>
        <div class="tooltip-connections"></div>
    </div>
    
    <div class="infinite-marker">∞ Open-Ended Network ∞</div>

    <script>
        const canvas = document.getElementById('network');
        const ctx = canvas.getContext('2d');
        const tooltip = document.getElementById('tooltip');
        
        let width, height;
        let animating = true;
        let mouseX = 0, mouseY = 0;
        let hoveredNode = null;
        let cameraX = 0, cameraY = 0;
        let targetCameraX = 0, targetCameraY = 0;
        let zoom = 1;
        let isDragging = false;
        let dragStartX, dragStartY;
        
        const colors = {
            fire: '#ff6b35',
            energy: '#e63946',
            tools: '#f4a261',
            bio: '#2a9d8f',
            info: '#4cc9f0',
            agi: '#9d4edd'
        };
        
        const nodes = [
            { id: 'fire', label: 'Fire', cluster: 'fire', x: 0, y: 0, size: 28, connections: ['cooking', 'warmth', 'light', 'ceramics', 'metallurgy'] },
            { id: 'cooking', label: 'Cooking', cluster: 'fire', x: -80, y: -100, size: 16, connections: ['nutrition', 'fermentation'] },
            { id: 'warmth', label: 'Warmth', cluster: 'fire', x: 100, y: -60, size: 14, connections: ['shelter', 'clothing'] },
            { id: 'light', label: 'Light', cluster: 'fire', x: 60, y: 80, size: 14, connections: ['temporal-freedom'] },
            { id: 'ceramics', label: 'Ceramics', cluster: 'fire', x: -100, y: 60, size: 15, connections: ['containers', 'metallurgy'] },
            { id: 'metallurgy', label: 'Metallurgy', cluster: 'fire', x: -40, y: 120, size: 20, connections: ['bronze', 'iron', 'steel'] },
            
            { id: 'stone-tools', label: 'Stone Tools', cluster: 'tools', x: -250, y: -50, size: 18, connections: ['fire', 'cutting', 'hammers'] },
            { id: 'cutting', label: 'Cutting', cluster: 'tools', x: -320, y: -120, size: 12, connections: ['agriculture'] },
            { id: 'hammers', label: 'Hammers', cluster: 'tools', x: -330, y: 20, size: 12, connections: ['metallurgy', 'chisels'] },
            { id: 'chisels', label: 'Chisels', cluster: 'tools', x: -380, y: 80, size: 11, connections: ['precision'] },
            { id: 'lathe', label: 'Lathe', cluster: 'tools', x: -300, y: 150, size: 17, connections: ['precision', 'bearings', 'machine-tools'] },
            { id: 'precision', label: 'Precision', cluster: 'tools', x: -350, y: 220, size: 14, connections: ['measurement', 'transistor'] },
            { id: 'machine-tools', label: 'Machine Tools', cluster: 'tools', x: -250, y: 250, size: 16, connections: ['manufacturing', 'robotics'] },
            
            { id: 'steam', label: 'Steam Engine', cluster: 'energy', x: 150, y: 180, size: 18, connections: ['metallurgy', 'electricity', 'locomotives'] },
            { id: 'electricity', label: 'Electricity', cluster: 'energy', x: 220, y: 100, size: 22, connections: ['telegraph', 'motors', 'computing', 'grid'] },
            { id: 'grid', label: 'Power Grid', cluster: 'energy', x: 300, y: 180, size: 15, connections: ['computing', 'agi'] },
            { id: 'combustion', label: 'Combustion', cluster: 'energy', x: 180, y: 280, size: 16, connections: ['steam', 'automobiles', 'flight'] },
            { id: 'nuclear', label: 'Nuclear', cluster: 'energy', x: 320, y: 280, size: 17, connections: ['physics', 'grid', 'agi'] },
            { id: 'solar', label: 'Solar', cluster: 'energy', x: 380, y: 220, size: 14, connections: ['photosynthesis', 'grid'] },
            
            { id: 'agriculture', label: 'Agriculture', cluster: 'bio', x: -150, y: -200, size: 18, connections: ['cooking', 'irrigation', 'breeding'] },
            { id: 'breeding', label: 'Selective Breeding', cluster: 'bio', x: -220, y: -280, size: 13, connections: ['genetics'] },
            { id: 'fermentation', label: 'Fermentation', cluster: 'bio', x: -50, y: -180, size: 12, connections: ['chemistry', 'medicine'] },
            { id: 'medicine', label: 'Medicine', cluster: 'bio', x: 50, y: -220, size: 16, connections: ['chemistry', 'microscopy', 'antibiotics'] },
            { id: 'genetics', label: 'Genetics', cluster: 'bio', x: -100, y: -320, size: 15, connections: ['dna', 'crispr'] },
            { id: 'crispr', label: 'CRISPR', cluster: 'bio', x: -30, y: -380, size: 14, connections: ['information', 'synbio', 'agi'] },
            { id: 'synbio', label: 'Synthetic Biology', cluster: 'bio', x: 60, y: -340, size: 13, connections: ['manufacturing', 'agi'] },
            { id: 'neural-interface', label: 'Neural Interfaces', cluster: 'bio', x: 150, y: -300, size: 14, connections: ['agi', 'medicine'] },
            
            { id: 'language', label: 'Language', cluster: 'info', x: 280, y: -150, size: 17, connections: ['writing', 'culture'] },
            { id: 'writing', label: 'Writing', cluster: 'info', x: 350, y: -80, size: 16, connections: ['printing', 'mathematics'] },
            { id: 'printing', label: 'Printing', cluster: 'info', x: 420, y: -20, size: 15, connections: ['mass-media', 'science'] },
            { id: 'telegraph', label: 'Telegraph', cluster: 'info', x: 380, y: 60, size: 14, connections: ['electricity', 'telephone', 'internet'] },
            { id: 'computing', label: 'Computing', cluster: 'info', x: 450, y: 120, size: 20, connections: ['transistor', 'internet', 'ai'] },
            { id: 'transistor', label: 'Transistor', cluster: 'info', x: 500, y: 50, size: 19, connections: ['precision', 'computing', 'agi'] },
            { id: 'internet', label: 'Internet', cluster: 'info', x: 520, y: 180, size: 18, connections: ['computing', 'data', 'agi'] },
            { id: 'ai', label: 'Machine Learning', cluster: 'info', x: 480, y: 260, size: 17, connections: ['computing', 'data', 'agi'] },
            
            { id: 'agi', label: 'AGI', cluster: 'agi', x: 400, y: 350, size: 30, connections: ['ai', 'neural-interface', 'synbio', 'quantum', 'unknown1', 'unknown2'] },
            { id: 'quantum', label: 'Quantum Computing', cluster: 'agi', x: 320, y: 400, size: 15, connections: ['physics', 'agi'] },
            { id: 'unknown1', label: '?', cluster: 'agi', x: 480, y: 400, size: 12, connections: ['agi'] },
            { id: 'unknown2', label: '?', cluster: 'agi', x: 450, y: 450, size: 12, connections: ['agi'] },
            { id: 'unknown3', label: '∞', cluster: 'agi', x: 380, y: 480, size: 10, connections: ['agi'] }
        ];
        
        const nodeMap = new Map(nodes.map(n => [n.id, n]));
        
        const edges = [];
        nodes.forEach(node => {
            node.connections.forEach(targetId => {
                const target = nodeMap.get(targetId);
                if (target && !edges.find(e => 
                    (e.source === node.id && e.target === targetId) || 
                    (e.source === targetId && e.target === node.id)
                )) {
                    edges.push({ source: node.id, target: targetId });
                }
            });
        });
        
        nodes.forEach(n => {
            n.vx = 0;
            n.vy = 0;
            n.originalX = n.x;
            n.originalY = n.y;
        });
        
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width * devicePixelRatio;
            canvas.height = height * devicePixelRatio;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            ctx.scale(devicePixelRatio, devicePixelRatio);
        }
        
        window.addEventListener('resize', resize);
        resize();
        
        let time = 0;
        
        function animate() {
            if (!animating) {
                requestAnimationFrame(animate);
                return;
            }
            
            time += 0.008;
            
            cameraX += (targetCameraX - cameraX) * 0.08;
            cameraY += (targetCameraY - cameraY) * 0.08;
            
            nodes.forEach(node => {
                const drift = Math.sin(time + node.x * 0.01) * 2 + Math.cos(time * 0.7 + node.y * 0.01) * 2;
                node.x = node.originalX + drift;
                node.y = node.originalY + Math.cos(time + node.y * 0.01) * 2;
            });
            
            ctx.clearRect(0, 0, width, height);
            
            ctx.save();
            ctx.translate(width / 2 + cameraX, height / 2 + cameraY);
            ctx.scale(zoom, zoom);
            
            edges.forEach(edge => {
                const source = nodeMap.get(edge.source);
                const target = nodeMap.get(edge.target);
                if (!source || !target) return;
                
                const gradient = ctx.createLinearGradient(source.x, source.y, target.x, target.y);
                gradient.addColorStop(0, colors[source.cluster] + '40');
                gradient.addColorStop(1, colors[target.cluster] + '40');
                
                ctx.beginPath();
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 1;
                
                const midX = (source.x + target.x) / 2;
                const midY = (source.y + target.y) / 2;
                const offset = Math.sin(time * 2 + source.x * 0.05) * 15;
                
                ctx.moveTo(source.x, source.y);
                ctx.quadraticCurveTo(midX + offset, midY + offset, target.x, target.y);
                ctx.stroke();
                
                const pulsePos = (time * 0.3 + edge.source.charCodeAt(0) * 0.1) % 1;
                const pulseX = source.x + (target.x - source.x) * pulsePos;
                const pulseY = source.y + (target.y - source.y) * pulsePos;
                
                ctx.beginPath();
                ctx.arc(pulseX, pulseY, 2, 0, Math.PI * 2);
                ctx.fillStyle = colors[source.cluster] + '80';
                ctx.fill();
            });
            
            nodes.forEach(node => {
                const isHovered = hoveredNode === node;
                const baseSize = node.size;
                const size = isHovered ? baseSize * 1.3 : baseSize;
                const color = colors[node.cluster];
                
                const glowSize = size * 3;
                const glow = ctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, glowSize);
                glow.addColorStop(0, color + '30');
                glow.addColorStop(0.5, color + '10');
                glow.addColorStop(1, 'transparent');
                ctx.beginPath();
                ctx.arc(node.x, node.y, glowSize, 0, Math.PI * 2);
                ctx.fillStyle = glow;
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
                const nodeGradient = ctx.createRadialGradient(
                    node.x - size * 0.3, node.y - size * 0.3, 0,
                    node.x, node.y, size
                );
                nodeGradient.addColorStop(0, color);
                nodeGradient.addColorStop(1, color + '80');
                ctx.fillStyle = nodeGradient;
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
                ctx.strokeStyle = color;
                ctx.lineWidth = isHovered ? 2 : 1;
                ctx.stroke();
                
                if (node.id === 'fire' || node.id === 'agi') {
                    const ringCount = 3;
                    for (let i = 0; i < ringCount; i++) {
                        const ringPhase = (time + i * 0.33) % 1;
                        const ringSize = size + ringPhase * size * 2;
                        const ringAlpha = (1 - ringPhase) * 0.3;
                        ctx.beginPath();
                        ctx.arc(node.x, node.y, ringSize, 0, Math.PI * 2);
                        ctx.strokeStyle = color + Math.floor(ringAlpha * 255).toString(16).padStart(2, '0');
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                }
                
                if (isHovered || node.size > 16) {
                    ctx.font = `${isHovered ? '12px' : '10px'} 'JetBrains Mono', monospace`;
                    ctx.fillStyle = '#e8e6e3';
                    ctx.textAlign = 'center';
                    ctx.fillText(node.label, node.x, node.y + size + 16);
                }
            });
            
            ctx.restore();
            
            requestAnimationFrame(animate);
        }
        
        function screenToWorld(sx, sy) {
            return {
                x: (sx - width / 2 - cameraX) / zoom,
                y: (sy - height / 2 - cameraY) / zoom
            };
        }
        
        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            
            if (isDragging) {
                targetCameraX += e.clientX - dragStartX;
                targetCameraY += e.clientY - dragStartY;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                return;
            }
            
            const world = screenToWorld(mouseX, mouseY);
            
            hoveredNode = null;
            for (const node of nodes) {
                const dx = world.x - node.x;
                const dy = world.y - node.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < node.size * 1.5) {
                    hoveredNode = node;
                    break;
                }
            }
            
            if (hoveredNode) {
                canvas.style.cursor = 'pointer';
                tooltip.classList.add('visible');
                tooltip.style.left = (mouseX + 15) + 'px';
                tooltip.style.top = (mouseY + 15) + 'px';
                
                tooltip.querySelector('.tooltip-title').textContent = hoveredNode.label;
                tooltip.querySelector('.tooltip-cluster').textContent = hoveredNode.cluster.toUpperCase() + ' CLUSTER';
                tooltip.querySelector('.tooltip-connections').textContent = 
                    `${hoveredNode.connections.length} connections`;
            } else {
                canvas.style.cursor = 'grab';
                tooltip.classList.remove('visible');
            }
        });
        
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            canvas.style.cursor = 'grabbing';
        });
        
        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            canvas.style.cursor = hoveredNode ? 'pointer' : 'grab';
        });
        
        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            tooltip.classList.remove('visible');
        });
        
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            zoom = Math.max(0.3, Math.min(3, zoom * delta));
        });
        
        document.getElementById('resetView').addEventListener('click', () => {
            targetCameraX = 0;
            targetCameraY = 0;
            zoom = 1;
        });
        
        document.getElementById('toggleAnimation').addEventListener('click', (e) => {
            animating = !animating;
            e.target.textContent = animating ? '⏸' : '▶';
        });
        
        document.querySelectorAll('.legend-item').forEach(item => {
            item.addEventListener('click', () => {
                const cluster = item.dataset.cluster;
                const clusterNodes = nodes.filter(n => n.cluster === cluster);
                if (clusterNodes.length > 0) {
                    const avgX = clusterNodes.reduce((sum, n) => sum + n.x, 0) / clusterNodes.length;
                    const avgY = clusterNodes.reduce((sum, n) => sum + n.y, 0) / clusterNodes.length;
                    targetCameraX = -avgX * zoom;
                    targetCameraY = -avgY * zoom;
                }
            });
        });
        
        animate();
    </script>
</body>
</html>
